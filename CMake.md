## What's the difference between Building and Compiling?
**Compiling** : 
* Compiling is the process of translating source code written in a high-level programming language (JAVA/C++/C) into machine code language.
* During compilation, the source code is analyzed (checking syntax errors), translated to intermediate form (Assembly or bytecode) which can be understood by the computer. 

**Building** : 
* Building is a broader temr  that includes compilation, linking object files together, resolving independencies, generating executable files
## What are Makefiles and CMake?
Makefiles and CMake are both tools used in software development, particulary in compiling and building projects, especially those written in c/c++. 

**Makefiles** :
* Makefile is a script written in a format understood by the `make` utility.
* It specifies how to compile a program, linking them into executables or libraries.
* It allows developers to automate the building process by only recompiling files that have changed since the last build. 
* Powerful, but can become complex with large projects.

**CMake** : 
* CMake is a cross-platform build system generator. 
* It generates native build scripts (Makefiles, IDE project files).

## CMakeLists.txt structure
* `cmake_minimum_required(VERSION 3.22)` : This line specifies the minimum version of CMake required to build the project.   
* `project(HELLOAP)` : This line defines the name of the project.    
* `add_executable(hellobinary main.cpp src/calc.cpp)` : This line tells CMake to create an executable named "hellobinary" from compiling and linking together the source files `main.cpp` and `src/calc.cpp`. The resulting executable will be generated in the build directory when the project is built.    
* `target_include_directories(hellobianary PUBLIC include/)` : this line tells that any source files associated with the `hellobianary` target can include header files located in the `include/` directory.     
## How to generate Makefiles?
* Use `cmake -G "MinGW Makefiles"` to generate build files for a CMake project using the MinGW Makefiles generator.  
* Use `cmake ..` when you are in the build directory and want to generate build system files based on the CMakeLists.txt file in the parent directory.  
* Use `cmake .` or just `cmake` when you are in the source code directory and want to generate build system files in the current directory.  
* Use `cmake .. -d  var_name=value` when you want to pass arguments.  
## CMake configuration process : 
**1. Invocation :** Running CMake in the project directory, either from the command line or using an integrated development environment (IDE) that supports CMake.   
**2. CMakeLists.txt Parsing :** CMake reads the CMakeLists.txt file(s) in the project directory (including subdirectories) to extract the instructions for configuring the project (specifying source files, setting build options, defining tergets).     
**3. Configuration :** CMake generates a configuration for the project based on the information in the CMakeLists.txt file, it may determien system properties, locate dependencies and set variables based on user input or default values.  
**4.Generation of Build files :** CMake generates platform-specific build files (Makfiles, Visual Studio project files) defining how the project will be compiled, linked and packaged.   
**5. Build :** the generated build files are used to compile the project using the appropriate build system (make, ninja, visual studio) and install the project if it is configured.   
## CMake variables : 
* `${CMAKE_SOURCE_DIR}` : Displays the root source directory of the project.     
* `${CMAKE_CURRENT_SOURCE_DIR}`  : Displays the current source directory, it changes depending on where the CMake is called.  
* `${CMAKE_BIANARY_DIR}`  : Displays the root binary directory where files generated by CMake will be placed.  
* `${CMAKE_CURRENT_BIANARY_DIR}`  : Displays the curretn bianary directory.     
* `${CMAKE_GENERATOR}` : Displays the CMake generator currently used for the project.  
* `${CMAKE_CXX_STANDARD}` : Displays the specified C++ version to compile the source files.   
* `${CMAKE_CXX_STANDARD_REQUIRED}` : specifies if the selected language is required for compilation.

## CMake if : 
* `if (NOT var)`: This condition checks if the variable var is not set or is empty.  
* `if (var1 and var2)`: This condition checks if both var1 and var2 are set and are non-empty.  
* `if (var1 or var2)`: This condition checks if either var1 or var2 is set and non-empty.  
* `if (val matches expression)`: This condition checks if the value of val matches the regular expression specified by expression. For example, if ("hello" matches "^h.*$") will evaluate to true because the string "hello" starts with the letter 'h'.  
* `if (exists file)`: This condition checks if the specified file exists. For example, if (exists "myfile.txt") will evaluate to true if the file myfile.txt exists.  
* `if (var1 less var2)`: This condition checks if the value of var1 is less than the value of var2.  
* `if (var1 greater var2)`: This condition checks if the value of var1 is greater than the value of var2.  
* `if (var1 equal var2)`: This condition checks if the value of var1 is equal to the value of var2.  
* `if (target file_name)`: This condition checks if the specified target exists. In CMake, a target represents an executable, library, or custom target created with the add_executable, add_library, or add_custom_target commands.

## CMake functions 
`function (happynewyear arg1)`  
      `message ("arg1 ${arg1}")` : Prints the name of the argument arg1.  
      `message ("arg1 ${${arg1}}")` : Prints the value of the variables stored in arg1.  
      `message ("arg1 ${ARGN}")` : `ARGN`  contains a list of additional arguments.  
      `message ("arg1 ${ARGC}")` : `ARGC` holds the total number of arguments passed to the function.    
`endfunction()`

## CMake Cashe 
The CMake cache is a collection of key-value pairs representing each a configuration option or a variable and their corresponding value.  
When CMake is run for the first time, it generates a cache file named `CMakeCache.txt`, and it persists across multiple runs of CMake.

## CMake files 
* `FILE(READ "main.cpp" Main_text)` : Reads the content from main.cpp and stores it in Main_text.  
* `FILE(STRINGS "main.cpp" MAIN_txt)` : Reads the content from main.cpp line by line.  
* `FILE(STRINGS "main.cpp" MAIN_TXT REGEX "^int.")` : It stores only the lines thaat match the specific regular expression. 
* `FILE(GLOB_RECURSE SRCS "*.cpp")` : Searches recursevly and stores all the paths of files with .cpp in the current directory and its subdirectories.  
